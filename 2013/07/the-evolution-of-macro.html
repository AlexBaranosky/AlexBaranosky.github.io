
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>The Evolution of a Macro - (elegant coding from a more civilized age)</title>
  <meta name="author" content="Alex Baranosky">

  
  <meta name="description" content="At Runa, where I work, I work on a very large Clojure application which we service online merchants with in order to deliver real-time promotions to &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://AlexBaranosky.github.io/2013/07/the-evolution-of-macro.html">
  <link href="/favicon.ico" rel="icon">
  
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="(elegant coding from a more civilized age)" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   class="no-sidebar"  >
  <header role="banner"><hgroup>
  <h1>(elegant coding from a more civilized age)</h1>
  
    <h2><a href="/">Lisp++</a></h2>
  
</hgroup>

</header>
  <nav role="navigation">
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:AlexBaranosky.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">The Evolution of a Macro</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-28T02:59:00-07:00" pubdate data-updated="true">Jul 28<span>th</span>, 2013</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>At Runa, where I work, I work on a very large Clojure application which we service online merchants with in order to deliver real-time promotions to the browser. The runtime promotion determination core of the application is quite intricate and has both stateful and immutable parts. If not tested properly, you can make the mistake of letting any setup mutable state effect tests other than the intended test case.</p>

<p>I thought it&rsquo;d be fun to walk you through how I developed a macro to handle this type of situation at work. I think it is a pretty interesting example of how macros can evolve and what considerations might go into how you architect a meaty macro.</p>

<p><em>NOTE: The code has been simplified from the production code to better emphasize the important points.</em></p>

<h2>First Stab At a Stateful Test Macro</h2>

<p>Our first stab at this problem solves the basic initial version of the problem. Often this would be all you need to get the job done. This approach enables us to evaluate our test assertion from within a stateful scope, and we use the finally block of the try-catch to ensure that the rules are always set back to their original state when the test is done.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defmacro </span><span class="nv">with-rules</span> <span class="p">[</span><span class="nv">rules</span> <span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
</span><span class='line'>  <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">old-rules#</span> <span class="err">@</span><span class="nv">rules</span><span class="p">]</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">try</span>
</span><span class='line'>       <span class="p">(</span><span class="nf">reset!</span> <span class="nv">rules</span> <span class="p">(</span><span class="nf">evaluate-rules</span> <span class="o">~</span><span class="nv">rules</span><span class="p">))</span>
</span><span class='line'>       <span class="o">~@</span><span class="nv">body</span>
</span><span class='line'>       <span class="p">(</span><span class="nf">finally</span>
</span><span class='line'>         <span class="p">(</span><span class="nf">reset!</span> <span class="nv">rules</span> <span class="nv">old-rules#</span><span class="p">)))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">deftest</span> <span class="nv">test-priority-level</span>
</span><span class='line'> <span class="p">(</span><span class="nf">with-rules</span> <span class="p">(</span><span class="nf">def-rule</span> <span class="nv">priority-level</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="nv">true</span> <span class="p">(</span><span class="nf">priority-level</span> <span class="mi">5</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then if we have some other sort of state, for example machine learning models, we can write another <code>with-models</code> macro and combine the macros in a test.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defmacro </span><span class="nv">with-models</span> <span class="p">[</span><span class="nv">models</span> <span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
</span><span class='line'> <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">old-models#</span> <span class="err">@</span><span class="nv">models</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">try</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">reset!</span> <span class="nv">models</span> <span class="o">~</span><span class="nv">models</span><span class="p">)</span>
</span><span class='line'>   <span class="o">~@</span><span class="nv">body</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">finally</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">reset!</span> <span class="nv">models</span> <span class="nv">old-models#</span><span class="p">)))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">deftest</span> <span class="nv">test-model-and-level</span>
</span><span class='line'> <span class="p">(</span><span class="nf">with-rules</span> <span class="p">(</span><span class="nf">def-rule</span> <span class="nv">priority-level</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">with-models</span> <span class="p">{</span><span class="ss">:a</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
</span><span class='line'>                <span class="ss">:b</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span><span class="p">]}</span> <span class="c1">;; insert fancy math stuff here ;)</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="nv">true</span> <span class="p">(</span><span class="nf">found-promotion?</span> <span class="p">(</span><span class="nf">legal-customer-session</span><span class="p">)))))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Before I make a serious change to the approach we use for this kind of macro, let&rsquo;s remove the bloat from these macros and make them lean mean macros with beefier functions to go with them.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">with-rules*</span> <span class="p">[</span><span class="nv">rules</span> <span class="nv">body-fn</span><span class="p">]</span>
</span><span class='line'> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">old-rules</span> <span class="err">@</span><span class="nv">rules</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">try</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">reset!</span> <span class="nv">rules</span> <span class="p">(</span><span class="nf">evaluate-rules</span> <span class="nv">rules</span><span class="p">))</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">body-fn</span><span class="p">)</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">finally</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">reset!</span> <span class="nv">rules</span> <span class="nv">old-rules</span><span class="p">)))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defmacro </span><span class="nv">with-rules</span> <span class="p">[</span><span class="nv">rules</span> <span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
</span><span class='line'> <span class="o">`</span><span class="p">(</span><span class="nf">with-rules*</span> <span class="o">~</span><span class="nv">rules</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="o">~@</span><span class="nv">body</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">with-models*</span> <span class="p">[</span><span class="nv">models</span> <span class="nv">body-fn</span><span class="p">]</span>
</span><span class='line'> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">old-models</span> <span class="err">@</span><span class="nv">models</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">try</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">reset!</span> <span class="nv">models</span> <span class="nv">models</span><span class="p">)</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">body-fn</span><span class="p">)</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">finally</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">reset!</span> <span class="nv">models</span> <span class="nv">old-models</span><span class="p">)))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defmacro </span><span class="nv">with-models</span> <span class="p">[</span><span class="nv">models</span> <span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
</span><span class='line'> <span class="o">`</span><span class="p">(</span><span class="nf">with-models*</span> <span class="o">~</span><span class="nv">models</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="o">~@</span><span class="nv">body</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Why? Because macros are harder to read, and not composable.</p>

<p>This way of approaching the stateful setup and teardown in our tests gets the
job done, but has a couple issues. As soon as we have another source of state we
need another with-x macro, and when we combine these together we end up over
time with code that looks like this.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">deftest</span> <span class="nv">test-motherload</span>
</span><span class='line'> <span class="p">(</span><span class="nf">with-x</span> <span class="nv">X</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">with-y</span> <span class="nv">Y</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">with-z</span> <span class="nv">Z</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">with-a</span> <span class="nv">A</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">with-b</span> <span class="nv">B</span>
</span><span class='line'>       <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">42</span> <span class="p">(</span><span class="nf">evaluate</span><span class="p">)))))))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>What I really want here is one macro not 5! I&rsquo;d like something I can easily extend as new forms of state come up.</p>

<h2>Composing Functions For A More Extensible Approach</h2>

<p>What if we could write test-motherload like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">deftest</span> <span class="nv">test-motherload</span>
</span><span class='line'> <span class="p">(</span><span class="nf">with-runtime-state</span> <span class="p">{</span><span class="ss">:x</span> <span class="nv">X</span> <span class="ss">:y</span> <span class="nv">Y</span> <span class="ss">:z</span> <span class="nv">Z</span> <span class="ss">:a</span> <span class="nv">A</span> <span class="ss">:b</span> <span class="nv">B</span><span class="p">}</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">42</span> <span class="p">(</span><span class="nf">evaluate</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And ideally if a C type of state comes up down the line, it&rsquo;ll be straightforward to extend this macro to accomodate it without pulling your hair out dealing with #&rsquo;s, ~&rsquo;s, @&rsquo;s, &lsquo;&rsquo;s and `&rsquo;s.</p>

<p>With a minor change to with-rules<em> and with-models</em> we can enable them to be used to compose 0-arity functions into other 0-arity functions.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">rules-setup-and-teardown</span> <span class="p">[</span><span class="nv">rules</span> <span class="nv">body-fn</span><span class="p">]</span>
</span><span class='line'> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">old-rules</span> <span class="err">@</span><span class="nv">rules</span><span class="p">]</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">try</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">reset!</span> <span class="nv">rules</span> <span class="p">(</span><span class="nf">evaluate-rules</span> <span class="nv">rules</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">body-fn</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">finally</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">reset!</span> <span class="nv">rules</span> <span class="nv">old-rules</span><span class="p">))))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">models-setup-and-teardown</span> <span class="p">[</span><span class="nv">models</span> <span class="nv">body-fn</span><span class="p">]</span>
</span><span class='line'> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">old-models</span> <span class="err">@</span><span class="nv">models</span><span class="p">]</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">try</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">reset!</span> <span class="nv">models</span> <span class="nv">models</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">body-fn</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">finally</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">reset!</span> <span class="nv">models</span> <span class="nv">old-models</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can take the testcase evaluation function and transform it into a function that when called will wrap the evaluate-test-case function in setup and teardown of the rules state.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">rules-setup-and-teardown</span>
</span><span class='line'>  <span class="o">&#39;</span><span class="p">(</span><span class="nf">def-rule</span> <span class="nv">priority-level</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="p">(</span><span class="nf">evalute-test-case</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And we can chain these function compositions together, to incorporate more varieties of setup and teardown as necessary. Note we don&rsquo;t need no fancy macros for this (yet).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">deftest</span> <span class="nv">test-model-and-level</span>
</span><span class='line'> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">testcase-fn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span>
</span><span class='line'>                     <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="nv">true</span> <span class="p">(</span><span class="nf">found-promotion?</span>
</span><span class='line'>                                   <span class="p">(</span><span class="nf">legal-customer-session</span><span class="p">)))))</span>
</span><span class='line'>       <span class="nv">wrapped-testcase-fn</span>
</span><span class='line'>         <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">testcase-fn</span>
</span><span class='line'>              <span class="p">(</span><span class="nf">rules-setup-and-teardown</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">def-rule</span> <span class="nv">priority-level</span> <span class="mi">5</span><span class="p">))</span>
</span><span class='line'>              <span class="p">(</span><span class="nf">models-setup-and-teardown</span> <span class="p">{</span><span class="ss">:a</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
</span><span class='line'>                                          <span class="ss">:b</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span><span class="p">]}))]</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">wrapped-testcase-fn</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Remember what we&rsquo;re aiming for is something more like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">deftest</span> <span class="nv">test-motherload</span>
</span><span class='line'> <span class="p">(</span><span class="nf">with-runtime-state</span> <span class="p">{</span><span class="ss">:x</span> <span class="nv">X</span> <span class="ss">:y</span> <span class="nv">Y</span> <span class="ss">:z</span> <span class="nv">Z</span> <span class="ss">:a</span> <span class="nv">A</span> <span class="ss">:b</span> <span class="nv">B</span><span class="p">}</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">42</span> <span class="p">(</span><span class="nf">evaluate</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is going to require us to convert the state map, {:x X :y Y :z Z :a A :b B}, into the appropriate setup-and-teardown wrapper functions, and do the wrapping of the body of the macro as well.</p>

<p>The first definition option->setup-and-teardown-fn, maps keys from the state map to its corresponding setup-and-teardown function.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:private</span> <span class="nv">option-&gt;setup-and-teardown-fn</span>
</span><span class='line'> <span class="s">&quot;Add new setup and teardown wrappers here, and the `with-runtime-state`</span>
</span><span class='line'><span class="s">  macro automatically gets a new functionality&quot;</span>
</span><span class='line'> <span class="p">{</span><span class="ss">:rules</span> <span class="o">#</span><span class="ss">&#39;rules-setup-and-teardown</span>
</span><span class='line'>  <span class="ss">:models</span> <span class="o">#</span><span class="ss">&#39;models-setup-and-teardown</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally the macro that makes it all fit together. If you look closely, it macro
expands into something very similar to the composed function solution above.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defmacro </span><span class="nv">with-runtime-state</span> <span class="p">[</span><span class="nv">options</span> <span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
</span><span class='line'> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">setup-and-teardowns</span>
</span><span class='line'>    <span class="c1">;; 1. map each key of the state-map to its a setup-and-teardown fn</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">for </span><span class="p">[[</span><span class="nv">k</span> <span class="nv">state-value</span><span class="p">]</span> <span class="nv">options</span><span class="p">]</span>
</span><span class='line'>     <span class="o">`</span><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">f#</span><span class="p">]</span>
</span><span class='line'>       <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">setup-and-teardown#</span> <span class="p">(</span><span class="nb">get </span><span class="o">~</span><span class="nv">option-&gt;setup-and-teardown-fn</span> <span class="o">~</span><span class="nv">k</span><span class="p">)]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">setup-and-teardown#</span> <span class="o">~</span><span class="nv">state-value</span> <span class="nv">f#</span><span class="p">)))))]</span>
</span><span class='line'>  <span class="c1">;; 2. thread the testcase body fn through each wrapper fn, and eval it</span>
</span><span class='line'>  <span class="o">`</span><span class="p">((</span><span class="nb">-&gt; </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="o">~@</span><span class="nv">body</span><span class="p">)</span>
</span><span class='line'>     <span class="o">~@</span><span class="nv">setup-and-teardowns</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can make the macro more user friendly with a couple of asserts on the args passed to it. These kinds of assertions are especially nice in macros, because they help make the macro&rsquo;s unique syntax easier to use for your teammates without them pulling their hair out.</p>

<p>Also, we can be improve it one step further. We&rsquo;ll use clojure.core/partial to create the 1-arity setup-and-teardown functions, rather than wrapping each of them within the for expression.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:private</span> <span class="nv">runtime-test-option-set</span> <span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">keys </span><span class="nv">option-&gt;setup-and-teardown-fn</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defmacro </span><span class="nv">with-runtime-state</span> <span class="p">[</span><span class="nv">options</span> <span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
</span><span class='line'> <span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">map? </span><span class="nv">options</span><span class="p">)</span>
</span><span class='line'>     <span class="s">&quot;Options should be a map.&quot;</span><span class="p">)</span>
</span><span class='line'> <span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">every? </span><span class="nv">runtime-test-option-set</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">options</span><span class="p">))</span>
</span><span class='line'>     <span class="s">&quot;Options should have :rules and/or :feature-bits keys&quot;</span><span class="p">)</span>
</span><span class='line'> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">setup-and-teardowns</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">for </span><span class="p">[[</span><span class="nv">k</span> <span class="nv">state-value</span><span class="p">]</span> <span class="nv">options</span><span class="p">]</span>
</span><span class='line'>     <span class="o">`</span><span class="p">((</span><span class="nb">partial </span><span class="p">(</span><span class="nb">get </span><span class="o">~</span><span class="nv">option-&gt;setup-and-teardown-fn</span> <span class="o">~</span><span class="nv">k</span><span class="p">)</span> <span class="o">~</span><span class="nv">state-value</span><span class="p">)))]</span>
</span><span class='line'>  <span class="o">`</span><span class="p">((</span><span class="nb">-&gt; </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="o">~@</span><span class="nv">body</span><span class="p">)</span>
</span><span class='line'>     <span class="o">~@</span><span class="nv">setup-and-teardowns</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Refactoring Addendum</h2>

<p>I thought a little more about this and realized that even this macro is doing
too much.  We can actually extract the code that wraps a 0-arity function f in
setup-and-teardown functions. In the process we end up with a macro with one
line of code that does the heavy lifting and a few more lines of asserts.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">wrap-in-setups-and-tear-downs</span> <span class="p">[</span><span class="nv">options</span> <span class="nv">f</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">setup-and-teardown-fns</span> <span class="p">(</span><span class="nb">for </span><span class="p">[[</span><span class="nv">k</span> <span class="nv">state-value</span><span class="p">]</span> <span class="nv">options</span><span class="p">]</span>
</span><span class='line'>                                 <span class="p">(</span><span class="nb">partial </span><span class="p">(</span><span class="nb">get </span><span class="nv">option-&gt;setup-and-teardown-fn</span> <span class="nv">k</span><span class="p">)</span>
</span><span class='line'>                                          <span class="nv">state-value</span><span class="p">))]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="o">&#39;</span> <span class="nv">setup-and-teardown-fn</span><span class="p">]</span>
</span><span class='line'>              <span class="p">(</span><span class="nf">setup-and-teardown-fn</span> <span class="nv">f</span><span class="o">&#39;</span><span class="p">))</span>
</span><span class='line'>            <span class="nv">f</span>
</span><span class='line'>            <span class="nv">setup-and-teardown-fns</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defmacro </span><span class="nv">with-runtime-state</span> <span class="p">[</span><span class="nv">options</span> <span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">map? </span><span class="nv">options</span><span class="p">)</span>
</span><span class='line'>          <span class="s">&quot;Options should be a map.&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">every? </span><span class="nv">runtime-test-option-set</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">options</span><span class="p">))</span>
</span><span class='line'>          <span class="s">&quot;Options should have :rules and/or :feature-bits keys&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="o">`</span><span class="p">((</span><span class="nf">wrap-in-setups-and-tear-downs</span> <span class="o">~</span><span class="nv">options</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="o">~@</span><span class="nv">body</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is a useful step because now we have another higher order function with which to build useful state-management tooling, and we&rsquo;ve eliminated more of the potentially confusing macro code.</p>

<h2>Takeaways</h2>

<h3>So why go to all this trouble?</h3>

<ul>
<li>We&rsquo;ve written a macro that is extensible.</li>
<li>We&rsquo;ve minimized actual lines of macro code. Yay!</li>
<li>We get validation of the state-map keys for free, anytime we extend this with a new setup-and-teardown function.</li>
<li>Our tests have a clean, uniform, minimal DSL for expressing pre-requisite mutable state.</li>
</ul>


<h3>How did we do it?</h3>

<ul>
<li>We took an essentially functional compositional approach.</li>
<li>We wrapped it in a layer of syntactic sugar.</li>
</ul>


<p>Hope you enjoyed this little code walk through.</p>

<p>Comments or questions?</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn"><a href="/about" title="About the author (Alex Baranosky)" rel="author">Alex Baranosky</a></span></span>

      








  


<time datetime="2013-07-28T02:59:00-07:00" pubdate data-updated="true">Jul 28<span>th</span>, 2013</time>
      

<span class="categories">
  
    <a class='category' href='/categories/clojure/'>clojure</a>, <a class='category' href='/categories/macro/'>macro</a>, <a class='category' href='/categories/testing/'>testing</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://AlexBaranosky.github.io/2013/07/the-evolution-of-macro.html" data-via="" data-counturl="http://AlexBaranosky.github.io/2013/07/the-evolution-of-macro.html" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/2012/12/slamhound-130-cleaning-up-all-your.html" title="Previous Post: Slamhound 1.3.0 - Cleaning up all your namespaces">&laquo; Slamhound 1.3.0 - Cleaning up all your namespaces</a>
      
      
        <a class="basic-alignment right" href="/2013/08/io-as-data.html" title="next Post: IO as Data">IO as Data &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Alex Baranosky -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'lispplusplus';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://AlexBaranosky.github.io/2013/07/the-evolution-of-macro.html';
        var disqus_url = 'http://AlexBaranosky.github.io/2013/07/the-evolution-of-macro.html';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
